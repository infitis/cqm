/******************************************************************************/
/***          Generated by IBExpert 2005.12.12 28.05.2006 12:29:23          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES WIN1251;

SET CLIENTLIB 'fbclient.dll';

CREATE DATABASE 'dnepr'
USER 'SYSDBA' PASSWORD 'boss1'
PAGE_SIZE 16384
DEFAULT CHARACTER SET WIN1251;



/******************************************************************************/
/***                         User Defined Functions                         ***/
/******************************************************************************/

DECLARE EXTERNAL FUNCTION ABS
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_abs' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ACOS
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_acos' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ADDDAY
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDHOUR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addHour' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMILLISECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMINUTE
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMONTH
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDSECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDWEEK
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDYEAR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addYear' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ASCII_CHAR
    INTEGER
    RETURNS CSTRING(1) FREE_IT
    ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ASCII_VAL
    CHAR(1)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_ascii_val' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ASIN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_asin' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ATAN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_atan' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ATAN2
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_atan2' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION BIN_AND
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_and' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION BIN_OR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_or' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION BIN_XOR
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_xor' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION CEILING
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_ceiling' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION COS
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_cos' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION COSH
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_cosh' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION COT
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_cot' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION DIV
    INTEGER,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_div' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION DNULLIF
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DNVL
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DOW
    TIMESTAMP,
    VARCHAR(15)
    RETURNS PARAMETER 2
    ENTRY_POINT 'DOW' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DPOWER
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'power' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION FLOOR
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_floor' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION GETEXACTTIMESTAMP
    TIMESTAMP
    RETURNS PARAMETER 1
    ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64NULLIF
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS NUMERIC(18,4) BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64NVL
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS NUMERIC(18,0) BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64ROUND
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbround' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64TRUNCATE
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION INULLIF
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION INVL
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION LN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_ln' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LOG
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_log' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LOG10
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_log10' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LOWER
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_lower' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LPAD
    CSTRING(255),
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LTRIM
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION MOD
    INTEGER,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_mod' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION PI

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_pi' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION RAND

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_rand' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ROUND
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbround' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION RPAD
    CSTRING(255),
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION RTRIM
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SDOW
    TIMESTAMP,
    VARCHAR(5)
    RETURNS PARAMETER 2
    ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SIGN
    DOUBLE PRECISION
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_sign' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SIN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_sin' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SINH
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_sinh' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SNULLIF
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SNVL
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SQRT
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_sqrt' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SRIGHT
    VARCHAR(100) BY DESCRIPTOR,
    SMALLINT,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'right' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRING2BLOB
    VARCHAR(300) BY DESCRIPTOR,
    BLOB
    RETURNS PARAMETER 2
    ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRLEN
    CSTRING(32767)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_strlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SUBSTR
    CSTRING(255),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SUBSTRLEN
    CSTRING(255),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION TAN
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_tan' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION TANH
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_tanh' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION TRUNCATE
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';




/******************************************************************************/
/***                                Domains                                 ***/
/******************************************************************************/

CREATE DOMAIN ASH AS
NUMERIC(2,2)
DEFAULT NULL
CHECK (value is null or VALUE BETWEEN 0.0 AND 100.0);

CREATE DOMAIN ASHSTRICT AS
DECIMAL(7,5)
DEFAULT NULL
CHECK (value is null or VALUE BETWEEN 0.0 AND 100.0);

CREATE DOMAIN COALRANKNAME AS
VARCHAR(8)
default ''
NOT NULL;

CREATE DOMAIN COALTY AS
INTEGER
DEFAULT 0
NOT NULL
CHECK (VALUE >=0);

CREATE DOMAIN ENTITYNAME AS
VARCHAR(16)
NOT NULL;

CREATE DOMAIN HUMIDITY AS
NUMERIC(2,2)
DEFAULT NULL
CHECK (value is null or VALUE BETWEEN 0.0 AND 100.0);

CREATE DOMAIN TIMEMOMENT AS
TIMESTAMP
DEFAULT 'NOW'
NOT NULL;

CREATE DOMAIN WEIGHT AS
DECIMAL(5,2)
DEFAULT NULL
CHECK (value is null or VALUE >= 0.0);

CREATE DOMAIN WEIGHTBIG AS
DECIMAL(10,2)
DEFAULT NULL
CHECK (value is null or VALUE >= 0.0);



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_COALRANKS_ID;
CREATE GENERATOR GEN_VAGONS_ID;


SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE ADD_COALTYPE (
    POS_ID INTEGER,
    COALRANK_ID INTEGER,
    COALTYPE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE COAL_SUM_POINT (
    NAME VARCHAR(16),
    T1 TIMESTAMP,
    T2 TIMESTAMP)
RETURNS (
    P DECIMAL(10,2),
    A DECIMAL(7,5),
    N INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE COAL_SUM_ROUTE (
    NAME VARCHAR(16),
    T1 TIMESTAMP,
    T2 TIMESTAMP)
RETURNS (
    P DECIMAL(10,2),
    A DECIMAL(7,5),
    N INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE COAL_SUM_VAGON (
    RWDATE1 DATE,
    RWDATE2 DATE,
    POS1 INTEGER,
    POS2 INTEGER,
    CERT1 INTEGER,
    CERT2 INTEGER)
RETURNS (
    P FLOAT,
    A FLOAT,
    W FLOAT,
    Q FLOAT,
    N INTEGER,
    COALRANK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE CQM$MIN2HOURMIN (
    MINS INTEGER)
RETURNS (
    HOURSMIN VARCHAR(20))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE GET_COALTYPE (
    POS_ID INTEGER,
    COALRANK_ID INTEGER)
RETURNS (
    COALTYPE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE GET_SMOOTH_ASH (
    POINT VARCHAR(16),
    PERIOD_SEC INTEGER,
    SMOOTH INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    AD NUMERIC(2,2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PACK_POINT (
    NAME VARCHAR(16),
    D1 INTEGER,
    D2 INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    POINT VARCHAR(16),
    P DECIMAL(10,2),
    A NUMERIC(2,2),
    N INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PACK_ROUTE (
    NAME VARCHAR(16),
    D1 INTEGER,
    D2 INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    ROUTE VARCHAR(16),
    P DECIMAL(10,2),
    A NUMERIC(2,2),
    N INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_ASH_POINT_GRAPH (
    NAME VARCHAR(16),
    DT1 TIMESTAMP,
    DT2 TIMESTAMP,
    SMOOTH INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    A NUMERIC(2,2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_ASH_ROUTE_GRAPH (
    NAME VARCHAR(16),
    DT1 TIMESTAMP,
    DT2 TIMESTAMP,
    SMOOTH INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    A NUMERIC(2,2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_ASH_VAGON_GRAPH (
    NAME VARCHAR(16),
    DT1 TIMESTAMP,
    DT2 TIMESTAMP)
RETURNS (
    MOMENT TIMESTAMP,
    A NUMERIC(2,2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_DAY_POINT (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT,
    WORKING_SHIFT SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(10,1),
    A DECIMAL(7,1),
    TWORK VARCHAR(20))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_DAY_POS (
    RWDATE DATE)
RETURNS (
    POS INTEGER,
    POSNAME VARCHAR(256),
    CERT VARCHAR(16),
    COU INTEGER,
    WEI DECIMAL(10,2),
    A FLOAT,
    W FLOAT,
    Q FLOAT,
    COALRANKNAME VARCHAR(8))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_DAY_ROUTE (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT,
    WORKING_SHIFT SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(10,1),
    A DECIMAL(7,1),
    TWORK VARCHAR(20))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_INTERVAL_ROUTE (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT,
    WORKING_SHIFT SMALLINT)
RETURNS (
    ID INTEGER,
    DT1 VARCHAR(25),
    DT2 VARCHAR(25),
    P DECIMAL(10,1),
    A DECIMAL(7,1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_MONTH_POINT (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(7,1),
    A DECIMAL(3,1),
    TWORK VARCHAR(20))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_MONTH_POS (
    RWDATE DATE)
RETURNS (
    POS INTEGER,
    POSNAME VARCHAR(256),
    CERT VARCHAR(16),
    COU INTEGER,
    WEI DECIMAL(10,2),
    A FLOAT,
    W FLOAT,
    Q FLOAT,
    COALRANKNAME VARCHAR(8))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REP_MONTH_ROUTE (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(7,1),
    A DECIMAL(3,1),
    TWORK VARCHAR(20))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SET_ACCUM (
    NAME VARCHAR(16),
    P DECIMAL(10,2),
    A DECIMAL(7,5),
    N FLOAT,
    COALTYPE INTEGER,
    EMPTY SMALLINT)
AS
BEGIN
  EXIT;
END^



SET TERM ; ^


/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ACCUMULATORS (
    MOMENT    TIMEMOMENT NOT NULL,
    NAME      ENTITYNAME NOT NULL,
    P         WEIGHTBIG,
    A         ASHSTRICT,
    N         FLOAT,
    COALTYPE  COALTY DEFAULT 0,
    EMPTY     SMALLINT DEFAULT 1 NOT NULL
);

CREATE TABLE CALIBRATION (
    MOMENT    TIMEMOMENT,
    POINT     ENTITYNAME,
    COALTYPE  COALTY,
    PARAM     VARCHAR(20) default 'parameter name' NOT NULL,
    VAL       FLOAT default 0,
    COMMENT   VARCHAR(64) default 'add comment'
);

CREATE TABLE COALRANKS (
    ID    INTEGER NOT NULL,
    NAME  COALRANKNAME,
    HHV   FLOAT,
    K     FLOAT
);

CREATE TABLE COALTYPES (
    COALRANK_ID  INTEGER NOT NULL,
    POS_ID       INTEGER NOT NULL,
    COALTYPE     COALTY NOT NULL
);

CREATE TABLE POINTS (
    MOMENT    TIMEMOMENT,
    POINT     ENTITYNAME,
    COALTYPE  COALTY,
    P         WEIGHT,
    A         ASH,
    DIAG      INTEGER default 0
);

CREATE TABLE POSITS (
    ID       INTEGER NOT NULL,
    NAME     VARCHAR(256) NOT NULL,
    STATION  VARCHAR(256),
    A        ASH,
    W        HUMIDITY
);

CREATE TABLE ROUTES (
    MOMENT  TIMEMOMENT,
    ROUTE   ENTITYNAME,
    P       WEIGHT,
    A       ASH
);

CREATE TABLE VAGONS (
    ID        INTEGER NOT NULL,
    MOMENT    TIMEMOMENT,
    VNAME     ENTITYNAME,
    COALTYPE  COALTY,
    P         WEIGHT,
    A         ASH,
    MP        INTEGER,
    LNFP      FLOAT,
    WEI       WEIGHT,
    W         HUMIDITY,
    RWDATE    DATE,
    NUMBER    INTEGER,
    POS       INTEGER,
    CERT      INTEGER,
    COALRANK  INTEGER
);



/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE VAGONS ADD CONSTRAINT UNQ1_VAGONS UNIQUE (ID, MOMENT, VNAME)
USING INDEX ID;


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCUMULATORS ADD CONSTRAINT PK_ACCUMULATORS PRIMARY KEY (NAME);
ALTER TABLE CALIBRATION ADD PRIMARY KEY (POINT, COALTYPE, PARAM);
ALTER TABLE COALRANKS ADD CONSTRAINT PK_COALRANKS PRIMARY KEY (ID);
ALTER TABLE COALTYPES ADD CONSTRAINT PK_COALTYPES PRIMARY KEY (COALRANK_ID, POS_ID, COALTYPE);
ALTER TABLE POINTS ADD PRIMARY KEY (MOMENT, POINT);
ALTER TABLE POSITS ADD CONSTRAINT PK_POSITS PRIMARY KEY (ID);
ALTER TABLE ROUTES ADD PRIMARY KEY (MOMENT, ROUTE);
ALTER TABLE VAGONS ADD CONSTRAINT PK_VAGONS PRIMARY KEY (ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE COALTYPES ADD CONSTRAINT FK_COALTYPES_POS FOREIGN KEY (POS_ID) REFERENCES POSITS (ID);
ALTER TABLE COALTYPES ADD CONSTRAINT FK_COALTYPES_RANK FOREIGN KEY (COALRANK_ID) REFERENCES COALRANKS (ID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;


/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: CALIBRATION_BU0 */
CREATE TRIGGER CALIBRATION_BU0 FOR CALIBRATION
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
if (old.moment = new.moment ) then new.moment='NOW';
end
^

/* Trigger: COALRANKS_BI */
CREATE TRIGGER COALRANKS_BI FOR COALRANKS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_COALRANKS_ID,1);
END
^

/* Trigger: VAGONS_BI */
CREATE TRIGGER VAGONS_BI FOR VAGONS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_VAGONS_ID,1);
END
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE ADD_COALTYPE (
    POS_ID INTEGER,
    COALRANK_ID INTEGER,
    COALTYPE INTEGER)
AS
begin
if (pos_id >= 0) then
    pos_id = pos_id;
else
    pos_id = 0;

if (coalrank_id >= 0) then
    coalrank_id = coalrank_id;
else
    coalrank_id = 0;


UPDATE coaltypes SET
    coaltype = :coaltype
WHERE
    pos_id = :pos_id
AND coalrank_id = :coalrank_id;

IF (ROW_COUNT = 0) THEN
    insert into coaltypes
    values(:coalrank_id, :pos_id, :coaltype);

end
^

ALTER PROCEDURE COAL_SUM_POINT (
    NAME VARCHAR(16),
    T1 TIMESTAMP,
    T2 TIMESTAMP)
RETURNS (
    P DECIMAL(10,2),
    A DECIMAL(7,5),
    N INTEGER)
AS
DECLARE VARIABLE PI DECIMAL(5,2);
DECLARE VARIABLE AI NUMERIC(2,2);
DECLARE VARIABLE PA DECIMAL(10,2);
begin
    a = 0; p = 0; n = 0;
    for
        select p, a
        from points
        where point=:name
            and moment >  :t1
            and moment <= :t2
        into :pi, :ai
    do
    begin
        -- BEGIN ADD ASH --
        if (not ((ai is null) or (ai<1.0) or (pi is null) or (pi<0.01)
                )
           ) then
            begin
                if ((pa is null) or (pa<0.01)) then
                    begin
                    a  = ai;
                    pa = pi;
                    end
                else
                    begin
                    a = (a*pa+ai*pi)/(pa+pi);
                    pa = pa + pi;
                    end
            end
        -- END   ADD ASH -----
        ----------------------
        -- BEGIN ADD WEIGHT --
        if (not (
                    (pi is null) or (pi <=0.01) or (pi is null) or (pi <=0.01)
                )
           ) then
        if (p is not null) then
            p = p + pi;
        -- END   ADD WEIGHT --
        ----------------------
        -- BEGIN ADD N --
        n = n + 1;
        -- END   ADD N --
    end
end
^

ALTER PROCEDURE COAL_SUM_ROUTE (
    NAME VARCHAR(16),
    T1 TIMESTAMP,
    T2 TIMESTAMP)
RETURNS (
    P DECIMAL(10,2),
    A DECIMAL(7,5),
    N INTEGER)
AS
DECLARE VARIABLE PI DECIMAL(5,2);
DECLARE VARIABLE AI NUMERIC(2,2);
DECLARE VARIABLE PA DECIMAL(10,2);
begin
    a = 0; p = 0; n = 0;
    for
        select p, a
        from routes
        where route=:name
            and moment >  :t1
            and moment <= :t2
        into :pi, :ai
    do
    begin
        -- BEGIN ADD ASH --
        if (not ((ai is null) or (ai<1.0) or (pi is null) or (pi<0.01)
                )
           ) then
            begin
                if ((pa is null) or (pa<0.01)) then
                    begin
                    a  = ai;
                    pa = pi;
                    end
                else
                    begin
                    a = (a*pa+ai*pi)/(pa+pi);
                    pa = pa + pi;
                    end
            end
        -- END   ADD ASH -----
        ----------------------
        -- BEGIN ADD WEIGHT --
        if (not (
                    (pi is null) or (pi <=0.01) or (pi is null) or (pi <=0.01)
                )
           ) then
        if (p is not null) then
            p = p + pi;
        -- END   ADD WEIGHT --
        ----------------------
        -- BEGIN ADD N --
        n = n + 1;
        -- END   ADD N --
    end
end
^

ALTER PROCEDURE COAL_SUM_VAGON (
    RWDATE1 DATE,
    RWDATE2 DATE,
    POS1 INTEGER,
    POS2 INTEGER,
    CERT1 INTEGER,
    CERT2 INTEGER)
RETURNS (
    P FLOAT,
    A FLOAT,
    W FLOAT,
    Q FLOAT,
    N INTEGER,
    COALRANK INTEGER)
AS
DECLARE VARIABLE AI NUMERIC(2,2);
DECLARE VARIABLE PI DECIMAL(5,2);
DECLARE VARIABLE WI NUMERIC(2,2);
DECLARE VARIABLE PA DECIMAL(10,2);
DECLARE VARIABLE COALRANKI INTEGER;
DECLARE VARIABLE K FLOAT;
DECLARE VARIABLE HHV FLOAT;
begin
    a = 0; p = 0; w = 0; q = null; n = 0;
    coalrank = null;
    for
    select wei, a, w, coalrank from vagons
    where rwdate >= :rwdate1 and
          rwdate <= :rwdate2 and
          pos >= :pos1 and
          pos <= :pos2 and
          cert >= :cert1 and
          cert <= :cert2 and
          pos is not null and
          cert is not null and
          wei is not null and
          a is not null
    into :pi, :ai, :wi, :coalranki
    do
    begin
        -- BEGIN ADD ASH --
        if (not ((ai is null) or (ai<1.0) or (pi is null) or (pi<0.01)
                )
           ) then
            begin
                if ((pa is null) or (pa<0.01)) then
                    begin
                    a  = ai;
                    pa = pi;
                    end
                else
                    begin
                    a = (a*pa+ai*pi)/(pa+pi);
                    pa = pa + pi;
                    end
            end
        -- END   ADD ASH -----
        ----------------------
        -- BEGIN ADD HUM --
        if (not ((wi is null) or (wi<1.0) or (pi is null) or (pi<0.01)
                )
           ) then
            begin
                w = (w*p+wi*pi)/(p+pi);
            end
        -- END   ADD HUM -----
        ----------------------
        -- BEGIN ADD WEIGHT --
        if (not (
                    (pi is null) or (pi <=0.01) or (pi is null) or (pi <=0.01)
                )
           ) then
        if (p is not null) then
            p = p + pi;
        -- END   ADD WEIGHT --
        ----------------------
        -- BEGIN ADD N --
        n = n + 1;
        -- END   ADD N --
        -- COALRANK --
        if (coalrank is null) then
            coalrank = coalranki;
        else if (coalrank != coalranki) then
            coalrank = -1;
        --
    end
    -- calculate Q
    if (coalrank > 0) then
    begin
        select k, hhv
        from coalranks
        where id = :coalrank
        into :k, :hhv;
        q = hhv*(1-a/100.0)*(1-w/100.0) - 2.442*(w/100.0+k*(1-a/100.0)*(1-w/100.0));
    end
    else
        coalrank = null;
    --
    suspend;
end
^

ALTER PROCEDURE CQM$MIN2HOURMIN (
    MINS INTEGER)
RETURNS (
    HOURSMIN VARCHAR(20))
AS
begin
HOURSMIN = '';
if (MINS < 2) then
    exit;
if (MINS/60 > 0) then
    HOURSMIN = cast(MINS/60 as varchar(6)) || ' ч. ';
if (MINS - (MINS/60)*60 > 0) then
    HOURSMIN = HOURSMIN || cast(MINS - (MINS/60)*60 as varchar(2)) || ' мин.';
end
^

ALTER PROCEDURE GET_COALTYPE (
    POS_ID INTEGER,
    COALRANK_ID INTEGER)
RETURNS (
    COALTYPE INTEGER)
AS
begin
  select first 1 coaltype
    from coaltypes
    where  (pos_id=:pos_id and coalrank_id = :coalrank_id)
        or (pos_id=:pos_id and coalrank_id = 0)
        or (pos_id=0       and coalrank_id = :coalrank_id)
        or (pos_id=0       and coalrank_id=0)
    order by coalrank_id desc, pos_id desc
    into :coaltype;

  suspend;
end
^

ALTER PROCEDURE GET_SMOOTH_ASH (
    POINT VARCHAR(16),
    PERIOD_SEC INTEGER,
    SMOOTH INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    AD NUMERIC(2,2))
AS
DECLARE VARIABLE A1 NUMERIC(2,2);
DECLARE VARIABLE A2 NUMERIC(2,2);
DECLARE VARIABLE A3 NUMERIC(2,2);
DECLARE VARIABLE A4 NUMERIC(2,2);
DECLARE VARIABLE A5 NUMERIC(2,2);
DECLARE VARIABLE A6 NUMERIC(2,2);
DECLARE VARIABLE N1 INTEGER;
DECLARE VARIABLE N2 INTEGER;
DECLARE VARIABLE N3 INTEGER;
DECLARE VARIABLE N4 INTEGER;
DECLARE VARIABLE N5 INTEGER;
DECLARE VARIABLE N6 INTEGER;
begin
a1=0; a2=0; a3=0; a4=0; a5=0; a6=0;
n1=0; n2=0; n3=0; n4=0; n5=0; n6=0;
for select moment, a
    from points
    where point=:point
        -- and cast(current_timestamp - moment as decimal(17,4)) <= cast(cast(:period_sec as float)/86400.0 as decimal(17,4))
        and moment > addsecond(current_timestamp, -:period_sec)
        and a is not null and a>0
    order by moment
    into :moment, :ad
do
begin
if (smooth = 1) then
begin
    suspend;
end
else if (smooth = 6) then
begin
    a6=a5;
    a5=a4;
    a4=a3;
    a3=a2;
    a2=a1;
    a1=ad;
    n6=n5;
    n5=n4;
    n4=n3;
    n3=n2;
    n2=n1;
    n1=1;
    ad = (a1+a2+a3+a4+a5+a6)/(n1+n2+n3+n4+n5+n6);
    suspend;
end
else
begin
    a3=a2;
    a2=a1;
    a1=ad;
    n3=n2;
    n2=n1;
    n1=1;
    ad = (a1+a2+a3)/(n1+n2+n3);
    suspend;
end
end
end
^

ALTER PROCEDURE PACK_POINT (
    NAME VARCHAR(16),
    D1 INTEGER,
    D2 INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    POINT VARCHAR(16),
    P DECIMAL(10,2),
    A NUMERIC(2,2),
    N INTEGER)
AS
DECLARE VARIABLE H INTEGER;
DECLARE VARIABLE T1 TIMESTAMP;
DECLARE VARIABLE T2 TIMESTAMP;
begin
if (d1>d2) then
    exit;
while (d1 <= d2) do
begin
    h = 0;
    while (h<=23) do
    begin
        t1 = addhour(addday(current_date, d1), h);
        t2 = addhour(t1, 1);
        
        execute procedure coal_sum_point(name, t1, t2)
            returning_values :p, :a, :n;

        if (n>2) then
        begin
            delete from points
                where point=:name
                and moment > :t1
                and moment <=:t2;
            insert into points
                values(addsecond(:t2, -1), :name, 0, :p, :a, 0);
            moment = t2;
            point = name;
            suspend;
        end
        h = h + 1;
    end
d1 = d1 + 1;
end

end
^

ALTER PROCEDURE PACK_ROUTE (
    NAME VARCHAR(16),
    D1 INTEGER,
    D2 INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    ROUTE VARCHAR(16),
    P DECIMAL(10,2),
    A NUMERIC(2,2),
    N INTEGER)
AS
DECLARE VARIABLE H INTEGER;
DECLARE VARIABLE T1 TIMESTAMP;
DECLARE VARIABLE T2 TIMESTAMP;
begin
if (d1>d2) then
    exit;
while (d1 <= d2) do
begin
    h = 0;
    while (h<=23) do
    begin
        t1 = addhour(addday(current_date, d1), h);
        t2 = addhour(t1, 1);
        
        execute procedure coal_sum_route(name, t1, t2)
            returning_values :p, :a, :n;

        if (n>2) then
        begin
            delete from routes
                where route=:name
                and moment > :t1
                and moment <=:t2;
            insert into routes
                values(addsecond(:t2, -1), :name, :p, :a);
            moment = t2;
            route = name;
            suspend;
        end
        h = h + 1;
    end
d1 = d1 + 1;
end

end
^

ALTER PROCEDURE REP_ASH_POINT_GRAPH (
    NAME VARCHAR(16),
    DT1 TIMESTAMP,
    DT2 TIMESTAMP,
    SMOOTH INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    A NUMERIC(2,2))
AS
DECLARE VARIABLE A1 DECIMAL(2,2);
DECLARE VARIABLE A2 DECIMAL(2,2);
DECLARE VARIABLE A3 DECIMAL(2,2);
DECLARE VARIABLE A4 DECIMAL(2,2);
DECLARE VARIABLE A5 DECIMAL(2,2);
DECLARE VARIABLE A6 DECIMAL(2,2);
DECLARE VARIABLE N1 INTEGER;
DECLARE VARIABLE N2 INTEGER;
DECLARE VARIABLE N3 INTEGER;
DECLARE VARIABLE N4 INTEGER;
DECLARE VARIABLE N5 INTEGER;
DECLARE VARIABLE N6 INTEGER;
begin
a1=0; a2=0; a3=0; a4=0; a5=0; a6=0;
n1=0; n2=0; n3=0; n4=0; n5=0; n6=0;
for select moment, a
    from points
    where point=:name
        and moment>=:dt1 and moment<=:dt2
        and a is not null and a>1
    order by moment
    into :moment, :a
do
    begin
        if (smooth = 1) then
            suspend;

        else
     /* if (smooth = 6) then */
            begin
                a6=a5;
                a5=a4;
                a4=a3;
                a3=a2;
                a2=a1;
                a1=a;
                n6=n5;
                n5=n4;
                n4=n3;
                n3=n2;
                n2=n1;
                n1=1;
                a = (a1+a2+a3+a4+a5+a6)/(n1+n2+n3+n4+n5+n6);
                suspend;
            end
    end
end
^

ALTER PROCEDURE REP_ASH_ROUTE_GRAPH (
    NAME VARCHAR(16),
    DT1 TIMESTAMP,
    DT2 TIMESTAMP,
    SMOOTH INTEGER)
RETURNS (
    MOMENT TIMESTAMP,
    A NUMERIC(2,2))
AS
DECLARE VARIABLE A1 DECIMAL(2,2);
DECLARE VARIABLE A2 DECIMAL(2,2);
DECLARE VARIABLE A3 DECIMAL(2,2);
DECLARE VARIABLE A4 DECIMAL(2,2);
DECLARE VARIABLE A5 DECIMAL(2,2);
DECLARE VARIABLE A6 DECIMAL(2,2);
DECLARE VARIABLE N1 INTEGER;
DECLARE VARIABLE N2 INTEGER;
DECLARE VARIABLE N3 INTEGER;
DECLARE VARIABLE N4 INTEGER;
DECLARE VARIABLE N5 INTEGER;
DECLARE VARIABLE N6 INTEGER;
begin
a1=0; a2=0; a3=0; a4=0; a5=0; a6=0;
n1=0; n2=0; n3=0; n4=0; n5=0; n6=0;
for select moment, a
    from routes
    where route=:name
        and moment>=:dt1 and moment<=:dt2
        and a is not null and a>1
    order by moment
    into :moment, :a
do
    begin
        if (smooth = 1) then
            suspend;

        else
     /* if (smooth = 6) then */
            begin
                a6=a5;
                a5=a4;
                a4=a3;
                a3=a2;
                a2=a1;
                a1=a;
                n6=n5;
                n5=n4;
                n4=n3;
                n3=n2;
                n2=n1;
                n1=1;
                a = (a1+a2+a3+a4+a5+a6)/(n1+n2+n3+n4+n5+n6);
                suspend;
            end
    end
end
^

ALTER PROCEDURE REP_ASH_VAGON_GRAPH (
    NAME VARCHAR(16),
    DT1 TIMESTAMP,
    DT2 TIMESTAMP)
RETURNS (
    MOMENT TIMESTAMP,
    A NUMERIC(2,2))
AS
begin

for select moment, a
    from vagons
    where vname=:name
        and moment>=:dt1 and moment<=:dt2
        and a is not null and a>1
    order by moment
    into :moment, :a
do
    suspend;

end
^

ALTER PROCEDURE REP_DAY_POINT (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT,
    WORKING_SHIFT SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(10,1),
    A DECIMAL(7,1),
    TWORK VARCHAR(20))
AS
DECLARE VARIABLE H SMALLINT;
DECLARE VARIABLE H_IN_S SMALLINT;
DECLARE VARIABLE T1 TIMESTAMP;
DECLARE VARIABLE THOURS INTEGER;
DECLARE VARIABLE CUR_S INTEGER;
DECLARE VARIABLE NWORK INTEGER;
BEGIN
H = 1;
H_IN_S = 1;
ID = 0;
CUR_S = 1;
WHILE (H<=24) DO
BEGIN
    EXECUTE PROCEDURE COAL_SUM_POINT
                :NAME,
                ADDHOUR(D, STARTHOUR+H-1),
                ADDHOUR(D, STARTHOUR+H)
            RETURNING_VALUES :P, :A, :NWORK;
    -- PREPARE T --
    T1 = ADDHOUR(D, STARTHOUR+H);
    THOURS = EXTRACT(HOUR FROM T1);
    T = CAST(THOURS AS VARCHAR(2)) || ':00';
    -- PREPARE TWORK --
    EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
    --
    ID = ID +1;
    SUSPEND;
    IF (H_IN_S=WORKING_SHIFT) THEN
    BEGIN
        EXECUTE PROCEDURE COAL_SUM_POINT
                    :NAME,
                    ADDHOUR(D, STARTHOUR+H-WORKING_SHIFT),
                    ADDHOUR(D, STARTHOUR+H)
                RETURNING_VALUES :P, :A, :NWORK;
        T = 'смена ' || CAST(CUR_S AS VARCHAR(2));
        -- PREPARE TWORK --
        TWORK = '';
        if (NWORK>7) then
            EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
        --
        ID = ID +1;
        SUSPEND;
        CUR_S = CUR_S + 1; H_IN_S = 0;
        -- EMPTY ROW --
        T = ''; P = NULL; A = NULL; TWORK = NULL;
        ID = ID +1;
        SUSPEND;
    END
    H = H + 1;
    H_IN_S = H_IN_S + 1;
END
-- SUMMARY --
EXECUTE PROCEDURE COAL_SUM_POINT
            :NAME,
            ADDHOUR(D, STARTHOUR),
            ADDHOUR(D, STARTHOUR+24)
                RETURNING_VALUES :P, :A, :NWORK;
T = 'итого';
-- PREPARE TWORK --
TWORK = '';
if (NWORK>25) then
    EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
--
ID = ID +1;
SUSPEND;
CUR_S = CUR_S + 1; H_IN_S = 0;
END
^

ALTER PROCEDURE REP_DAY_POS (
    RWDATE DATE)
RETURNS (
    POS INTEGER,
    POSNAME VARCHAR(256),
    CERT VARCHAR(16),
    COU INTEGER,
    WEI DECIMAL(10,2),
    A FLOAT,
    W FLOAT,
    Q FLOAT,
    COALRANKNAME VARCHAR(8))
AS
DECLARE VARIABLE POS_WAS INTEGER;
DECLARE VARIABLE POS_I INTEGER;
DECLARE VARIABLE CERT_I INTEGER;
DECLARE VARIABLE POS_MIN INTEGER;
DECLARE VARIABLE POS_MAX INTEGER;
DECLARE VARIABLE CERT_MIN INTEGER;
DECLARE VARIABLE CERT_MAX INTEGER;
DECLARE VARIABLE CERT_IN_POS INTEGER;
DECLARE VARIABLE COALRANK INTEGER;
begin
pos_was = null;
cert_in_pos = 0;

-- search min and max of cert --
select min(cert), max(cert)
from vagons
where rwdate = :rwdate and
      cert > 0 and
      cert is not null
into :cert_min, :cert_max;
      
-- search min and max of pos --
select min(pos), max(pos)
from vagons
where rwdate = :rwdate and
      pos > 0 and
      pos is not null
into :pos_min, :pos_max;
      
for
select distinct pos, cert
    from vagons
where rwdate = :rwdate and
      pos is not null and
      cert is not null
order by pos, cert
into :pos_i, :cert_i
do
begin

    if (pos_was is null) then
    begin
        pos_was = pos_i;
    end
    if (pos_was != pos_i) then
    begin
        if (cert_in_pos > 1) then 
        begin
            execute procedure coal_sum_vagon(rwdate, rwdate, pos_was, pos_was, cert_min, cert_max)
                returning_values :wei, :a, :w, :q, :cou, :coalrank;
            cert = 'итого';
            pos = pos_was;
            coalrankname = null;
            select name from coalranks  where id = :coalrank
                into :coalrankname;
            suspend;
        end
        pos_was = pos_i;
        cert_in_pos = 1;
    end
    else
        cert_in_pos = cert_in_pos + 1;


    posname = null;
    select name
    from posits
    where id = :pos_i
    into :posname;

        execute procedure coal_sum_vagon(rwdate, rwdate, pos_i, pos_i, cert_i, cert_i)
            returning_values :wei, :a, :w, :q, :cou, :coalrank;
        pos = pos_i;
        cert = cert_i;
        coalrankname = null;
        select name from coalranks  where id = :coalrank
            into :coalrankname;
        suspend;
end
        -- last position summary --
        execute procedure coal_sum_vagon(rwdate, rwdate, pos_was, pos_was, cert_min, cert_max)
            returning_values :wei, :a, :w, :q, :cou, :coalrank;
        cert = 'итого';
        pos = pos_was;
        coalrankname = null;
        select name from coalranks  where id = :coalrank
            into :coalrankname;
        suspend;

        -- all position summary --
        execute procedure coal_sum_vagon(rwdate, rwdate, pos_min, pos_max, cert_min, cert_max)
            returning_values :wei, :a, :w, :q, :cou, :coalrank;
        cert = null;
        pos = null;
        posname = 'итого';
        coalrankname = null;
        select name from coalranks  where id = :coalrank
            into :coalrankname;
        suspend;
end
^

ALTER PROCEDURE REP_DAY_ROUTE (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT,
    WORKING_SHIFT SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(10,1),
    A DECIMAL(7,1),
    TWORK VARCHAR(20))
AS
DECLARE VARIABLE H SMALLINT;
DECLARE VARIABLE H_IN_S SMALLINT;
DECLARE VARIABLE T1 TIMESTAMP;
DECLARE VARIABLE THOURS INTEGER;
DECLARE VARIABLE CUR_S INTEGER;
DECLARE VARIABLE NWORK INTEGER;
BEGIN
H = 1;
H_IN_S = 1;
ID = 0;
CUR_S = 1;
WHILE (H<=24) DO
BEGIN
    EXECUTE PROCEDURE COAL_SUM_ROUTE
                :NAME,
                ADDHOUR(D, STARTHOUR+H-1),
                ADDHOUR(D, STARTHOUR+H)
            RETURNING_VALUES :P, :A, :NWORK;
    -- PREPARE T --
    T1 = ADDHOUR(D, STARTHOUR+H);
    THOURS = EXTRACT(HOUR FROM T1);
    T = CAST(THOURS AS VARCHAR(2)) || ':00';
    -- PREPARE TWORK --
    EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
    --
    ID = ID +1;
    SUSPEND;
    IF (H_IN_S=WORKING_SHIFT) THEN
    BEGIN
        EXECUTE PROCEDURE COAL_SUM_ROUTE
                    :NAME,
                    ADDHOUR(D, STARTHOUR+H-WORKING_SHIFT),
                    ADDHOUR(D, STARTHOUR+H)
                RETURNING_VALUES :P, :A, :NWORK;
        T = 'смена ' || CAST(CUR_S AS VARCHAR(2));
        -- PREPARE TWORK --
        TWORK = '';
        if (NWORK>7) then
            EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
        --
        ID = ID +1;
        SUSPEND;
        CUR_S = CUR_S + 1; H_IN_S = 0;
        -- EMPTY ROW --
        T = ''; P = NULL; A = NULL; TWORK = NULL;
        ID = ID +1;
        SUSPEND;
    END
    H = H + 1;
    H_IN_S = H_IN_S + 1;
END
-- SUMMARY --
EXECUTE PROCEDURE COAL_SUM_ROUTE
            :NAME,
            ADDHOUR(D, STARTHOUR),
            ADDHOUR(D, STARTHOUR+24)
                RETURNING_VALUES :P, :A, :NWORK;
T = 'итого';
-- PREPARE TWORK --
TWORK = '';
if (NWORK>25) then
    EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
--
ID = ID +1;
SUSPEND;
CUR_S = CUR_S + 1; H_IN_S = 0;
END
^

ALTER PROCEDURE REP_INTERVAL_ROUTE (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT,
    WORKING_SHIFT SMALLINT)
RETURNS (
    ID INTEGER,
    DT1 VARCHAR(25),
    DT2 VARCHAR(25),
    P DECIMAL(10,1),
    A DECIMAL(7,1))
AS
DECLARE VARIABLE D1 TIMESTAMP;
DECLARE VARIABLE D2 TIMESTAMP;
DECLARE VARIABLE T1 TIMESTAMP;
DECLARE VARIABLE T2 TIMESTAMP;
DECLARE VARIABLE CUR_MOMENT TIMESTAMP;
DECLARE VARIABLE INTERVAL_BEGIN TIMESTAMP;
DECLARE VARIABLE N SMALLINT;
DECLARE VARIABLE H INTEGER;
BEGIN
id = 0;
D1 = ADDHOUR(D, STARTHOUR);
D2 = ADDHOUR(D, STARTHOUR+24);
T2 = D1;
interval_begin = d1;
SELECT FIRST 1 moment
    FROM ROUTES
    WHERE route = :NAME AND
        MOMENT > :D1 AND MOMENT <= :D2
    ORDER BY MOMENT
    INTO :T2;
interval_begin = t2;

FOR SELECT MOMENT
    FROM ROUTES
    WHERE route = :NAME AND
        MOMENT > :D1 AND MOMENT <= :D2
    ORDER BY MOMENT
    INTO :CUR_MOMENT
DO
BEGIN
    T1 = T2;
    T2 = CUR_MOMENT;
    if (ADDMINUTE(T1, 2) < T2) then
    begin
        execute procedure coal_sum_route :name, addminute(interval_begin, -1), t1
            returning_values :p, :a, :n;
        dt1 = substrlen(cast(interval_begin as time), 1, 8);
        dt2 = substrlen(cast(t1 as time), 1, 8);
        suspend;
        interval_begin = t2;
        id = id + 1;
    end
END
-- write last interval --
if (interval_begin != t2) then
begin
    execute procedure coal_sum_route :name, addminute(interval_begin, -1), t2
        returning_values :p, :a, :n;
    dt1 = substrlen(cast(interval_begin as time), 1, 8);
    dt2 = substrlen(cast(t2 as time),1 ,8);
    suspend;
    id = id + 1;
end
-- empty row --
a = null; p = null; dt1 = ''; dt2 = '';
suspend;
id = id + 1;
--
-- working shift --
if (working_shift > 0) then
begin
    h = 1;
    interval_begin = d1;
    while (h <= 24) do
    begin
        T2 = addhour(interval_begin, working_shift);
        execute procedure coal_sum_route :name, interval_begin, t2
            returning_values :p, :a, :n;
        dt1 = substrlen(cast(interval_begin as time), 1, 8);
        dt2 = substrlen(cast(t2 as time), 1, 8);
        suspend;
        id = id + 1;
        interval_begin = t2;
        h = h + working_shift;
    end

    -- empty row --
    a = null; p = null; dt1 = ''; dt2 = '';
    suspend;
    id = id + 1;
end
--
-- day summary
    execute procedure coal_sum_route :name, d1, d2
        returning_values :p, :a, :n;
    dt2 = 'итого';
    suspend;
    id = id + 1;
--
END
^

ALTER PROCEDURE REP_MONTH_POINT (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(7,1),
    A DECIMAL(3,1),
    TWORK VARCHAR(20))
AS
DECLARE VARIABLE DI SMALLINT;
DECLARE VARIABLE MONTHDAY SMALLINT;
DECLARE VARIABLE CURDAY DATE;
DECLARE VARIABLE THOURS INTEGER;
DECLARE VARIABLE NWORK INTEGER;
BEGIN
MONTHDAY = EXTRACT(DAY FROM D);
DI = MONTHDAY;
ID = 0;
WHILE (DI>0) DO
BEGIN
    CURDAY = ADDDAY(D, -DI+1);
    EXECUTE PROCEDURE COAL_SUM_POINT
                :NAME,
                ADDHOUR(CURDAY, STARTHOUR),
                ADDHOUR(CURDAY, STARTHOUR+24)
            RETURNING_VALUES :P, :A, :NWORK;
    -- PREPARE T --
    T = CURDAY;
    -- PREPARE TWORK --
    TWORK = '';
    if (NWORK>25) then
        EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
    --
    ID = ID +1;
    SUSPEND;

    DI = DI - 1;
END
-- EMPTY ROW --
T = ''; P = NULL; A = NULL; TWORK = NULL;
ID = ID +1;
SUSPEND;
-- SUMMARY --
CURDAY = ADDDAY(D, -MONTHDAY+1);
EXECUTE PROCEDURE COAL_SUM_POINT
            :NAME,
            ADDHOUR(CURDAY, STARTHOUR),
            ADDHOUR(D, STARTHOUR+24)
                RETURNING_VALUES :P, :A, :NWORK;
T = 'итого';
-- PREPARE TWORK --
TWORK = '';
if (addday(d, 40) > current_date) then
    EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
--
ID = ID +1;
SUSPEND;
END
^

ALTER PROCEDURE REP_MONTH_POS (
    RWDATE DATE)
RETURNS (
    POS INTEGER,
    POSNAME VARCHAR(256),
    CERT VARCHAR(16),
    COU INTEGER,
    WEI DECIMAL(10,2),
    A FLOAT,
    W FLOAT,
    Q FLOAT,
    COALRANKNAME VARCHAR(8))
AS
DECLARE VARIABLE D1 DATE;
DECLARE VARIABLE POS_I INTEGER;
DECLARE VARIABLE POS_MIN INTEGER;
DECLARE VARIABLE POS_MAX INTEGER;
DECLARE VARIABLE CERT_MIN INTEGER;
DECLARE VARIABLE CERT_MAX INTEGER;
DECLARE VARIABLE COALRANK INTEGER;
begin
d1 = addday(rwdate, 1-extract(day from rwdate));

-- search min and max of cert --
select min(cert), max(cert)
from vagons
where rwdate >= :d1 and
      rwdate <= :rwdate and
      cert > 0 and
      cert is not null
into :cert_min, :cert_max;
      
-- search min and max of pos --
select min(pos), max(pos)
from vagons
where rwdate >= :d1 and
      rwdate <= :rwdate and
      pos > 0 and
      pos is not null
into :pos_min, :pos_max;
      
for
select distinct pos
    from vagons
where rwdate >= :d1 and
      rwdate <= :rwdate and
      pos is not null and
      cert is not null
order by pos
into :pos_i
do
begin

    posname = null;
    select name
    from posits
    where id = :pos_i
    into :posname;

        execute procedure coal_sum_vagon(d1, rwdate, pos_i, pos_i, cert_min, cert_max)
            returning_values :wei, :a, :w, :q, :cou, :coalrank;
        pos = pos_i;
        cert = 'с начала месяца';
        coalrankname = null;
        select name from coalranks  where id = :coalrank
            into :coalrankname;
        suspend;
end
        -- all position summary --
        execute procedure coal_sum_vagon(d1, rwdate, pos_min, pos_max, cert_min, cert_max)
            returning_values :wei, :a, :w, :q, :cou, :coalrank;
        cert = 'с начала месяца';
        pos = null;
        posname = 'итого';
        coalrankname = null;
        select name from coalranks  where id = :coalrank
            into :coalrankname;
        suspend;
end
^

ALTER PROCEDURE REP_MONTH_ROUTE (
    NAME VARCHAR(16),
    D DATE,
    STARTHOUR SMALLINT)
RETURNS (
    ID INTEGER,
    T VARCHAR(20),
    P DECIMAL(7,1),
    A DECIMAL(3,1),
    TWORK VARCHAR(20))
AS
DECLARE VARIABLE DI SMALLINT;
DECLARE VARIABLE MONTHDAY SMALLINT;
DECLARE VARIABLE CURDAY DATE;
DECLARE VARIABLE THOURS INTEGER;
DECLARE VARIABLE NWORK INTEGER;
BEGIN
MONTHDAY = EXTRACT(DAY FROM D);
DI = MONTHDAY;
ID = 0;
WHILE (DI>0) DO
BEGIN
    CURDAY = ADDDAY(D, -DI+1);
    EXECUTE PROCEDURE COAL_SUM_ROUTE
                :NAME,
                ADDHOUR(CURDAY, STARTHOUR),
                ADDHOUR(CURDAY, STARTHOUR+24)
            RETURNING_VALUES :P, :A, :NWORK;
    -- PREPARE T --
    T = CURDAY;
    -- PREPARE TWORK --
    TWORK = '';
    if (NWORK>25) then
        EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
    --
    ID = ID +1;
    SUSPEND;

    DI = DI - 1;
END
-- EMPTY ROW --
T = ''; P = NULL; A = NULL; TWORK = NULL;
ID = ID +1;
SUSPEND;
-- SUMMARY --
CURDAY = ADDDAY(D, -MONTHDAY+1);
EXECUTE PROCEDURE COAL_SUM_ROUTE
            :NAME,
            ADDHOUR(CURDAY, STARTHOUR),
            ADDHOUR(D, STARTHOUR+24)
                RETURNING_VALUES :P, :A, :NWORK;
T = 'итого';
-- PREPARE TWORK --
TWORK = '';
if (addday(d, 40) > current_date) then
    EXECUTE PROCEDURE CQM$MIN2HOURMIN :NWORK RETURNING_VALUES :TWORK;
--
ID = ID +1;
SUSPEND;
END
^

ALTER PROCEDURE SET_ACCUM (
    NAME VARCHAR(16),
    P DECIMAL(10,2),
    A DECIMAL(7,5),
    N FLOAT,
    COALTYPE INTEGER,
    EMPTY SMALLINT)
AS
begin

UPDATE accumulators SET
    p = :p,
    a = :a,
    n = :n,
    coaltype = :coaltype,
    empty = :empty,
    moment = 'now'
WHERE name = :name;

IF (ROW_COUNT = 0) THEN
INSERT INTO accumulators (name, p, a, n, coaltype, empty, moment)
VALUES (:name, :p, :a, :n, :coaltype, :empty, 'now');
end
^


SET TERM ; ^


/******************************************************************************/
/***                               Privileges                               ***/
/******************************************************************************/


/* Privileges of users */
GRANT SELECT ON COALRANKS TO CLIENT;
GRANT SELECT ON POINTS TO CLIENT;
GRANT SELECT, INSERT, UPDATE, DELETE ON POSITS TO CLIENT;
GRANT SELECT ON ROUTES TO CLIENT;
GRANT ALL ON VAGONS TO CLIENT;
GRANT EXECUTE ON PROCEDURE GET_SMOOTH_ASH TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_ASH_POINT_GRAPH TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_ASH_ROUTE_GRAPH TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_ASH_VAGON_GRAPH TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_DAY_POINT TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_DAY_POS TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_DAY_ROUTE TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_INTERVAL_ROUTE TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_MONTH_POINT TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_MONTH_POS TO CLIENT;
GRANT EXECUTE ON PROCEDURE REP_MONTH_ROUTE TO CLIENT;
GRANT SELECT ON RDB$ROLES TO PUBLIC;
GRANT ALL ON ACCUMULATORS TO SERVER;
GRANT SELECT, UPDATE ON CALIBRATION TO SERVER;
GRANT ALL ON COALRANKS TO SERVER;
GRANT SELECT, DELETE ON COALTYPES TO SERVER;
GRANT ALL ON POINTS TO SERVER;
GRANT ALL ON POSITS TO SERVER;
GRANT ALL ON ROUTES TO SERVER;
GRANT ALL ON VAGONS TO SERVER;
GRANT EXECUTE ON PROCEDURE ADD_COALTYPE TO SERVER;
GRANT EXECUTE ON PROCEDURE GET_COALTYPE TO SERVER;
GRANT EXECUTE ON PROCEDURE PACK_POINT TO SERVER;
GRANT EXECUTE ON PROCEDURE PACK_ROUTE TO SERVER;
GRANT EXECUTE ON PROCEDURE SET_ACCUM TO SERVER;

/* Privileges of procedures */
GRANT SELECT, INSERT, UPDATE, DELETE ON COALTYPES TO PROCEDURE ADD_COALTYPE;
GRANT SELECT ON ROUTES TO PROCEDURE COAL_SUM_ROUTE;
GRANT SELECT ON POINTS TO PROCEDURE GET_SMOOTH_ASH;
GRANT EXECUTE ON PROCEDURE COAL_SUM_POINT TO PROCEDURE PACK_POINT;
GRANT SELECT, INSERT, DELETE ON ROUTES TO PROCEDURE PACK_ROUTE;
GRANT EXECUTE ON PROCEDURE COAL_SUM_ROUTE TO PROCEDURE PACK_ROUTE;
GRANT SELECT ON POINTS TO PROCEDURE REP_ASH_POINT_GRAPH;
GRANT EXECUTE ON PROCEDURE COAL_SUM_POINT TO PROCEDURE REP_DAY_POINT;
GRANT EXECUTE ON PROCEDURE CQM$MIN2HOURMIN TO PROCEDURE REP_DAY_POINT;
GRANT EXECUTE ON PROCEDURE COAL_SUM_VAGON TO PROCEDURE REP_DAY_POS;
GRANT EXECUTE ON PROCEDURE CQM$MIN2HOURMIN TO PROCEDURE REP_DAY_POS;
GRANT EXECUTE ON PROCEDURE COAL_SUM_ROUTE TO PROCEDURE REP_DAY_ROUTE;
GRANT EXECUTE ON PROCEDURE CQM$MIN2HOURMIN TO PROCEDURE REP_DAY_ROUTE;
GRANT EXECUTE ON PROCEDURE COAL_SUM_ROUTE TO PROCEDURE REP_INTERVAL_ROUTE;
GRANT EXECUTE ON PROCEDURE COAL_SUM_POINT TO PROCEDURE REP_MONTH_POINT;
GRANT EXECUTE ON PROCEDURE CQM$MIN2HOURMIN TO PROCEDURE REP_MONTH_POINT;
GRANT EXECUTE ON PROCEDURE COAL_SUM_VAGON TO PROCEDURE REP_MONTH_POS;
GRANT EXECUTE ON PROCEDURE CQM$MIN2HOURMIN TO PROCEDURE REP_MONTH_POS;
GRANT EXECUTE ON PROCEDURE COAL_SUM_ROUTE TO PROCEDURE REP_MONTH_ROUTE;
GRANT EXECUTE ON PROCEDURE CQM$MIN2HOURMIN TO PROCEDURE REP_MONTH_ROUTE;
